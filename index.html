<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Dragon Snake</title>
<style>
  :root {
    --bg: #0f172a;
    --panel: #111827;
    --accent: #22c55e;
    --accent2: #86efac;
    --danger: #ef4444;
    --text: #e5e7eb;
  }
  html, body { height: 100%; margin: 0; }
  body {
    background: radial-gradient(1200px 600px at 50% -20%, #1f2937, var(--bg));
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    display: grid;
    place-items: center;
    gap: 16px;
  }
  .wrap {
    display: grid;
    gap: 10px;
    justify-items: center;
  }
  .topbar {
    display: flex;
    gap: 12px;
    align-items: center;
    justify-content: center;
    background: #0b1220aa;
    padding: 8px 12px;
    border-radius: 10px;
    box-shadow: inset 0 0 0 1px #ffffff0f, 0 6px 18px #00000066;
  }
  .badge { color: #a5b4fc; }
  .score { color: var(--accent2); font-weight: 700; }
  .hi { color: #fde68a; font-weight: 700; }
  canvas {
    background: linear-gradient(180deg, #0b1220, #0a0f1a);
    border-radius: 14px;
    box-shadow: inset 0 0 0 1px #ffffff12, 0 12px 30px #00000066;
    image-rendering: pixelated;
    outline: none;
  }
  .controls { display: flex; gap: 8px; flex-wrap: wrap; justify-content: center; }
  button {
    background: #111827;
    color: var(--text);
    border: 1px solid #ffffff1a;
    padding: 8px 12px;
    border-radius: 10px;
    cursor: pointer;
  }
  button:hover { border-color: #ffffff2e; }
  .overlay {
    position: absolute;
    inset: 0;
    display: grid;
    place-items: center;
    pointer-events: none;
  }
  .card {
    background: #0b1220ee;
    border: 1px solid #ffffff1a;
    padding: 14px 16px;
    border-radius: 12px;
    text-align: center;
    max-width: 360px;
  }
  .kbd { font-family: ui-monospace, Menlo, Consolas, monospace; background: #111827; padding: 2px 6px; border-radius: 6px; border: 1px solid #ffffff22; }
  .hint { color: #9ca3af; font-size: 12px; }
  .stage { position: relative; }

  /* Modal styles */
  .modal {
    position: fixed;
    inset: 0;
    display: none;
    align-items: center;
    justify-content: center;
    background: rgba(0,0,0,0.6);
    z-index: 9999;
  }
  .modal.is-visible { display: flex; }
  .modal-content {
    background: #0b1220ee;
    border: 1px solid #ffffff1a;
    padding: 20px;
    border-radius: 12px;
    width: min(520px, 92%);
    box-shadow: 0 8px 24px rgba(0,0,0,0.25);
    color: var(--text);
  }
  .modal-content h2 { margin: 0 0 8px 0; }
  .modal-actions { margin-top: 14px; text-align: right; }
  .modal input[type="text"] {
    width: 100%;
    padding: 8px 10px;
    border-radius: 8px;
    border: 1px solid #ffffff22;
    background: #071022;
    color: var(--text);
    margin-top: 8px;
  }
  .btn-primary {
    background: linear-gradient(180deg,#2563eb,#1e40af);
    border: none;
    color: white;
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
  }
  .btn-primary:disabled { opacity: 0.5; cursor: default; }
  .btn-ghost {
    background: transparent;
    border: 1px solid #ffffff22;
    color: var(--text);
    padding: 8px 12px;
    border-radius: 8px;
    cursor: pointer;
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <div class="badge">üêâ Dragon Snake</div>
      <div>| Score: <span class="score" id="score">0</span></div>
      <div>| Best: <span class="hi" id="hi">0</span></div>
    </div>
    <div class="stage">
      <canvas id="c" width="420" height="420" tabindex="0" aria-label="Dragon Snake game"></canvas>
      <div class="overlay" id="overlay">
        <div class="card">
          <div style="font-size:18px; margin-bottom:6px">Guide the dragon, eat the sheep, grow long!</div>
          <div style="margin-bottom:8px">Avoid walls and your own tail.</div>
          <div class="hint" style="margin-bottom:8px">
            Move with <span class="kbd">Arrow Keys</span> or <span class="kbd">WASD</span> ¬∑ Pause <span class="kbd">P</span> ¬∑ Restart <span class="kbd">R</span>
          </div>
          <div style="opacity:.9">Press any arrow key to begin</div>
        </div>
      </div>
    </div>
    <div class="controls">
      <button id="btn-start">Start</button>
      <button id="btn-pause">Pause</button>
      <button id="btn-restart">Restart</button>
    </div>
    <div class="hint">If you can't see the game, scroll up. You can also copy this page's HTML and open it locally in your browser.</div>
  </div>

  <!-- Intro Modal -->
  <div id="introModal" class="modal is-visible" aria-hidden="false">
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="introTitle">
      <h2 id="introTitle">Welcome</h2>
      <p id="introText">Enter your name to learn how to play. Make the dragon eat <strong>3 sheep</strong> to access the website.
        <br><strong>How to play:</strong><br>
            ‚Ä¢ Move with Arrow Keys or WASD<br>
            ‚Ä¢ Avoid walls and your own tail<br>
            ‚Ä¢ Press P to pause, R to restart
      </p>
      <label for="playerName">Your name</label>
      <input id="playerName" type="text" placeholder="Type your name" autocomplete="off" />
      <div class="modal-actions">
        <button id="introStartBtn" class="btn-primary" disabled>Start</button>
      </div>
    </div>
  </div>

  <!-- Try Again Modal -->
  <div id="tryAgainModal" class="modal" aria-hidden="true">
    <div class="modal-content" role="dialog" aria-modal="true" aria-labelledby="tryTitle">
      <h2 id="tryTitle">Try again</h2>
      <p>You didn't make the dragon eat 3 sheep. Want to try again?</p>
      <div class="modal-actions">
        <button id="retryBtn" class="btn-primary">Retry</button>
        <button id="cancelRetryBtn" class="btn-ghost" style="margin-left:8px">Cancel</button>
      </div>
    </div>
  </div>

<script>
(function() {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  const overlay = document.getElementById('overlay');
  const scoreEl = document.getElementById('score');
  const hiEl = document.getElementById('hi');
  const startBtn = document.getElementById('btn-start');
  const pauseBtn = document.getElementById('btn-pause');
  const restartBtn = document.getElementById('btn-restart');

  // Modal elements
  const introModal = document.getElementById('introModal');
  const introStartBtn = document.getElementById('introStartBtn');
  const playerNameInput = document.getElementById('playerName');
  const tryAgainModal = document.getElementById('tryAgainModal');
  const retryBtn = document.getElementById('retryBtn');
  const cancelRetryBtn = document.getElementById('cancelRetryBtn');

  // Hi score via localStorage
  const HI_KEY = 'dragon-snake-hi';
  let hi = Number(localStorage.getItem(HI_KEY) || 0);
  hiEl.textContent = hi;

  const tile = 20; // grid size in px
  const cols = canvas.width / tile | 0;
  const rows = canvas.height / tile | 0;

  // Game state
  let snake, dir, nextDir, food, score, running, paused, loopId, speedMs, started;
  // Gate variables
  let allowedToStart = false;
  let sheepEaten = 0;
  const sheepTarget = 3;

  function reset() {
    snake = [ {x: (cols/2|0), y: (rows/2|0)} ];
    dir = {x: 1, y: 0};
    nextDir = {x: 1, y: 0};
    score = 0;
    speedMs = 130;
    running = false;
    paused = false;
    started = false;
    placeFood();
    draw();
    updateScore();
    showOverlay(true);
  }

  function randInt(n) { return (Math.random() * n) | 0; }

  function placeFood() {
    let ok = false;
    while (!ok) {
      food = { x: randInt(cols), y: randInt(rows) };
      ok = !snake.some(s => s.x === food.x && s.y === food.y);
    }
  }

  function updateScore() {
    scoreEl.textContent = score;
    if (score > hi) { hi = score; localStorage.setItem(HI_KEY, hi); hiEl.textContent = hi; }
  }

  function start() {
    if (!allowedToStart) return; // prevent starting before intro
    if (running) return;
    running = true; paused = false; started = true; showOverlay(false);
    canvas.focus();
    loop();
  }

  function pauseToggle(force) {
    if (!running) return;
    paused = (typeof force === 'boolean') ? force : !paused;
    if (paused) {
      cancelAnimationFrame(loopId);
      showOverlay(true, 'Paused ‚Äî press P to resume');
    } else {
      showOverlay(false);
      loop();
    }
  }

  function gameOver() {
    running = false;
    cancelAnimationFrame(loopId);
    // Show try again modal (use endGame to centralize behavior)
    endGame(false);
  }

  function speedUp() {
    if (score && score % 5 === 0) {
      speedMs = Math.max(70, speedMs - 8);
    }
  }

  let lastStep = 0;
  function loop(ts = 0) {
    if (!running || paused) return;
    if (ts - lastStep >= speedMs) {
      step();
      lastStep = ts;
    }
    loopId = requestAnimationFrame(loop);
  }

  function step() {
    if (Math.abs(nextDir.x) !== Math.abs(dir.x) || Math.abs(nextDir.y) !== Math.abs(dir.y)) {
      dir = nextDir;
    }

    const head = { x: snake[0].x + dir.x, y: snake[0].y + dir.y };

    // wall collision
    if (head.x < 0 || head.y < 0 || head.x >= cols || head.y >= rows) {
      draw(head);
      return gameOver();
    }

    // self collision
    if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
      draw(head);
      return gameOver();
    }

    snake.unshift(head);

    if (head.x === food.x && head.y === food.y) {
      score++;
      // Count sheep eaten toward the gate goal
      onSheepEaten();
      speedUp();
      updateScore();
      placeFood();
    } else {
      snake.pop();
    }

    draw();
  }

  function draw(headCandidate) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Subtle grid
    ctx.strokeStyle = '#ffffff10';
    ctx.lineWidth = 1;
    for (let x = tile; x < canvas.width; x += tile) { ctx.beginPath(); ctx.moveTo(x+.5, 0); ctx.lineTo(x+.5, canvas.height); ctx.stroke(); }
    for (let y = tile; y < canvas.height; y += tile) { ctx.beginPath(); ctx.moveTo(0, y+.5); ctx.lineTo(canvas.width, y+.5); ctx.stroke(); }

    // Draw food (sheep üêë)
    const fx = food.x * tile + tile/2;
    const fy = food.y * tile + tile/2 + 1;
    ctx.font = (tile * 0.9) + 'px "Apple Color Emoji", "Segoe UI Emoji", Noto Color Emoji, system-ui, sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('üêë', fx, fy);

    // Draw snake (dragon üêâ for head + scaled body)
    for (let i = 0; i < snake.length; i++) {
      const seg = snake[i];
      const x = seg.x * tile;
      const y = seg.y * tile;
      if (i === 0) {
        const hx = x + tile/2;
        const hy = y + tile/2 + 1;
        ctx.fillText('üêâ', hx, hy);
      } else {
        const shade = 0.55 + Math.min(i / 20, 0.35);
        ctx.fillStyle = `hsl(140 60% ${Math.round(shade*50)}%)`;
        roundRect(ctx, x+2, y+2, tile-4, tile-4, 4);
        ctx.fill();
        ctx.strokeStyle = '#00000040';
        ctx.stroke();
      }
    }

    // Optional preview of death position
    if (headCandidate) {
      ctx.fillStyle = '#ef444480';
      ctx.fillRect(headCandidate.x*tile, headCandidate.y*tile, tile, tile);
    }
  }

  function roundRect(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.lineTo(x+w-r, y);
    ctx.quadraticCurveTo(x+w, y, x+w, y+r);
    ctx.lineTo(x+w, y+h-r);
    ctx.quadraticCurveTo(x+w, y+h, x+w-r, y+h);
    ctx.lineTo(x+r, y+h);
    ctx.quadraticCurveTo(x, y+h, x, y+h-r);
    ctx.lineTo(x, y+r);
    ctx.quadraticCurveTo(x, y, x+r, y);
    ctx.closePath();
  }

  // Input
  function setDir(dx, dy) {
    if (dx === -dir.x && dy === -dir.y) return;
    nextDir = {x: dx, y: dy};
    // Only auto-start if allowed (intro completed)
    if (!started && allowedToStart) start();
  }

  window.addEventListener('keydown', (e) => {
    const k = e.key.toLowerCase();
    if (k === 'arrowleft' || k === 'a') setDir(-1, 0);
    else if (k === 'arrowup' || k === 'w') setDir(0, -1);
    else if (k === 'arrowright' || k === 'd') setDir(1, 0);
    else if (k === 'arrowdown' || k === 's') setDir(0, 1);
    else if (k === 'p' || k === ' ') pauseToggle();
    else if (k === 'r') { reset(); start(); }
  });

  // Buttons
  startBtn.addEventListener('click', () => { if (!running && allowedToStart) { start(); } });
  pauseBtn.addEventListener('click', () => pauseToggle());
  restartBtn.addEventListener('click', () => { reset(); if (allowedToStart) start(); });

  function showOverlay(show, message) {
    overlay.style.display = show ? 'grid' : 'none';
    if (show) {
      const card = overlay.querySelector('.card');
      if (message) card.lastElementChild.textContent = message;
      else card.lastElementChild.textContent = 'Press any arrow key to begin';
    }
  }

  /* --- Gate and modal logic --- */

  // Enable start button only when name entered
  playerNameInput.addEventListener('input', () => {
    introStartBtn.disabled = playerNameInput.value.trim().length === 0;
  });

  // Focus input on modal open
  function openIntroModal() {
    showModal(introModal);
    playerNameInput.focus();
  }

  function showModal(modal) {
    modal.classList.add('is-visible');
    modal.setAttribute('aria-hidden', 'false');
  }

  function hideModal(modal) {
    modal.classList.remove('is-visible');
    modal.setAttribute('aria-hidden', 'true');
  }

  // Start from intro: allow game to run and hide modal
  introStartBtn.addEventListener('click', () => {
    const name = playerNameInput.value.trim();
    if (!name) return;
    // Save name if you want: localStorage.setItem('playerName', name);
    allowedToStart = true;
    hideModal(introModal);
    // Reset sheep counter for gate
    sheepEaten = 0;
    // Start the game
    reset();
    start();
  });

  // When a sheep is eaten in the game, call this
  function onSheepEaten() {
    if (!allowedToStart) return;
    sheepEaten += 1;
    // Optional: give a small message in overlay when 1 or 2 eaten
    if (sheepEaten > 0 && sheepEaten < sheepTarget) {
      showOverlay(true, `Nice! ${sheepEaten}/${sheepTarget} sheep eaten`);
      setTimeout(() => { if (running) showOverlay(false); }, 900);
    }
    if (sheepEaten >= sheepTarget) {
      // success
      endGame(true);
    }
  }

  // Centralized endGame handler
  function endGame(success) {
    running = false;
    cancelAnimationFrame(loopId);
    if (success) {
      // Redirect to main site page (relative)
      // You can change 'main.html' to the actual page you want to open
      window.location.href = 'main.html';
    } else {
      // Show try again modal
      showModal(tryAgainModal);
    }
  }

  // Retry button: hide try-again modal and restart the flow
  retryBtn.addEventListener('click', () => {
    hideModal(tryAgainModal);
    // Reset gate so they must re-enter name (optional). Here we show intro again.
    allowedToStart = false;
    playerNameInput.value = '';
    introStartBtn.disabled = true;
    openIntroModal();
  });

  // Cancel retry: just hide modal and show overlay message
  cancelRetryBtn.addEventListener('click', () => {
    hideModal(tryAgainModal);
    showOverlay(true, 'Game paused ‚Äî press Start to play');
  });

  // Initialize: show intro modal on load
  openIntroModal();
  reset();

  // Expose onSheepEaten to the local scope in case you want to call it elsewhere
  window._dragonSnake_onSheepEaten = onSheepEaten;

})();
</script>
</body>
</html>
